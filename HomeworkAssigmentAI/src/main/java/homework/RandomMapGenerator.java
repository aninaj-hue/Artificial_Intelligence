package homework;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Random;

import com.github.javafaker.Faker;

public class RandomMapGenerator
{
    // outside library used to generate a random city name
    public static final Faker faker = new Faker();
    // variable to store the random city name generated by faker.address().city();
    public static String randomCity;
    public static Random rand = new Random();

    // Number of the vertices in the graph. This variable will receive a value from the input file
    public int numberOfCities = 5000;
    // Number of the edges in the graph. This variable will receive a value from the input file
    public int numberOfRoads = 30000;

    // function to return a random int number between a given range [min, max]
    public double getRandomIntegerBetweenRange(double min, double max)
    {
        double x = (int)(Math.random()*((max-min)+1))+min;
        return x;
    }

    public List<Node> mapGenerator()
    {
        // Populate the map with nodes with random generated names which don't repeat
        HashMap<String,Node> map = new HashMap<String,Node>();
        for(int i = 0; i < numberOfCities; i++)
        {
            randomCity = faker.address().city();
            // if the map contains this name, then generate another one.
            while(map.containsKey(randomCity) == true)
            {
                randomCity = faker.address().city();
            }
            map.put(randomCity, new Node());
        }

        // Put the nodes from HashMap into an ArrayList and assign the value of the key to the Node's name attribute
        List<Node> list = new ArrayList<Node>();
        for(String i : map.keySet())
        {
            map.get(i).name = i;
            list.add(map.get(i));
        }

        // Establish a road between 2 consecutive nodes (0-1, 1-2 etc) so the map is "connected"
        // Since the "graph" is undirected we have to build a road not only from i to i+1 but also from i+1 to i.
        for(int i = 0; i < numberOfCities-1; i++)
        {
            int randomNumber = (int) getRandomIntegerBetweenRange(50,500);
            list.get(i).addNeighbour(list.get(i+1), randomNumber);
            list.get(i+1).addNeighbour(list.get(i), randomNumber);
        }

        // With the remaining number of edges we randomly select 2 nodes and if there is no
        // road between them, we build one.
        for(int i = 1; i <= numberOfRoads-numberOfCities+1; i++)
        {
            // Variable used to remember if there is an edge or not between the 2 randomly generated cities
            boolean checkExistingEdge = false;

            // We exit this loop only when there is an edge between the 2 cities. Otherwise we build one.
            while(true)
            {

                int randomCity1 = rand.nextInt(list.size());
                int randomCity2 = rand.nextInt(list.size());

                while(randomCity2 == randomCity1)
                {
                    randomCity2 = rand.nextInt(list.size());
                }

                // Iterate through the neighbours of first city to check if there is an edge to the second generated city
                for(int j = 0; j < list.get(randomCity1).adjacencyList.size(); j++)
                {
                    // Check if there is an edge between the 2 selected cities
                    if(list.get(randomCity1).adjacencyList.get(j).target == list.get(randomCity2))
                    {
                        checkExistingEdge = true;
                        break;
                    }
                }
                // If there is no edge then build one
                if(checkExistingEdge == false)
                {
                    int randomNumber = (int) getRandomIntegerBetweenRange(50,500);
                    list.get(randomCity1).addNeighbour(list.get(randomCity2), randomNumber);
                    list.get(randomCity2).addNeighbour(list.get(randomCity1), randomNumber);
                    break;
                }
                checkExistingEdge = false;
            }
        }

        return list;

    }
}
